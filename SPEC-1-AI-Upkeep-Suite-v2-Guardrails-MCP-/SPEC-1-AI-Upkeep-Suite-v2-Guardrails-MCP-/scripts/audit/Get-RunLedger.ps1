<#!
.SYNOPSIS
    Reads and validates entries from the run ledger.

.DESCRIPTION
    Get-RunLedger.ps1 parses a JSON Lines ledger produced by
    New-RunLedgerEntry.ps1, validates each entry against the ledger schema, and
    optionally verifies attached HMAC signatures. The cmdlet emits structured
    objects that downstream tooling can consume for reporting or alerting.

.PARAMETER LedgerPath
    Path to the JSONL ledger file generated by Stream H audit scripts.

.PARAMETER SigningKeyPath
    Path to the shared secret used to sign ledger entries. When supplied the
    script verifies the HMAC-SHA256 signature on every entry.

.PARAMETER SigningKey
    SecureString representation of the shared secret. This parameter is
    mutually exclusive with SigningKeyPath.

.PARAMETER IncludeRaw
    When provided, the cmdlet includes the original JSONL text for each entry in
    the output.

.PARAMETER AsJson
    Instructs the cmdlet to serialise the resulting collection as JSON instead
    of emitting PowerShell objects.

.EXAMPLE
    ./Get-RunLedger.ps1 -LedgerPath ./artifacts/run-ledger.jsonl -SigningKeyPath ~/.config/aiuokeep/hmac.key

.NOTES
    Author: AI Upkeep Suite - Stream H
    PowerShell 5.1 or later is required.
#>
[CmdletBinding(DefaultParameterSetName = 'Default')]
param(
    [Parameter(Mandatory, Position = 0)]
    [ValidateNotNullOrEmpty()]
    [string]$LedgerPath,

    [Parameter(ParameterSetName = 'Path')]
    [ValidateNotNullOrEmpty()]
    [string]$SigningKeyPath,

    [Parameter(ParameterSetName = 'Key')]
    [System.Security.SecureString]$SigningKey,

    [switch]$IncludeRaw,

    [switch]$AsJson
)

if ($PSCmdlet.ParameterSetName -eq 'Path' -and $SigningKey) {
    throw 'Provide either SigningKeyPath or SigningKey, not both.'
}

function ConvertTo-NormalisedObject {
    param(
        [Parameter(Mandatory)]
        [AllowNull()]
        $Value
    )

    if ($null -eq $Value) {
        return $null
    }

    if ($Value -is [System.Collections.IDictionary]) {
        $ordered = [ordered]@{}
        foreach ($key in ($Value.Keys | Sort-Object)) {
            $ordered[$key] = ConvertTo-NormalisedObject -Value $Value[$key]
        }
        return $ordered
    }

    if ($Value -is [System.Collections.IEnumerable] -and -not ($Value -is [string])) {
        $list = @()
        foreach ($item in $Value) {
            $list += ,(ConvertTo-NormalisedObject -Value $item)
        }
        return $list
    }

    return $Value
}

function ConvertTo-CanonicalJson {
    param(
        [Parameter(Mandatory)]
        $InputObject
    )

    $normalised = ConvertTo-NormalisedObject -Value $InputObject
    return (ConvertTo-Json -InputObject $normalised -Depth 32 -Compress)
}

function Get-SigningKeyBytes {
    param(
        [string]$Path,
        [System.Security.SecureString]$SecureKey
    )

    if ($Path) {
        try {
            $raw = Get-Content -Path $Path -Raw -ErrorAction Stop
        }
        catch {
            throw "Unable to read signing key from '$Path': $($_.Exception.Message)"
        }
    }
    elseif ($SecureKey) {
        $raw = [System.Net.NetworkCredential]::new([string]::Empty, $SecureKey).Password
    }
    else {
        return $null
    }

    if ([string]::IsNullOrWhiteSpace($raw)) {
        throw 'Signing key cannot be empty.'
    }

    $trimmed = $raw.Trim()
    if ($trimmed.Length -lt 32) {
        throw 'Signing key must be at least 32 characters long for adequate entropy.'
    }

    return [System.Text.Encoding]::UTF8.GetBytes($trimmed)
}

function ConvertTo-SignatureString {
    param(
        [Parameter(Mandatory)]
        [datetime]$Timestamp,

        [Parameter(Mandatory)]
        [ValidateSet('pass', 'fail')]
        [string]$Outcome,

        [Parameter(Mandatory)]
        [System.Collections.IEnumerable]$CheckItems,

        [hashtable]$MetadataPayload
    )

    $checksForSignature = @()
    foreach ($check in $CheckItems) {
        $map = @{}
        foreach ($property in $check.PSObject.Properties) {
            $map[$property.Name] = $property.Value
        }

        $duration = ''
        if ($map.ContainsKey('durationMs')) {
            $duration = $map['durationMs']
        }

        $tool = ''
        if ($map.ContainsKey('tool')) {
            $tool = $map['tool']
        }

        $detailsHash = ''
        if ($map.ContainsKey('details')) {
            $detailsHash = ConvertTo-CanonicalJson -InputObject $map['details']
        }

        $checksForSignature += ,('{0}|{1}|{2}|{3}|{4}' -f
            $map['name'],
            $map['status'],
            $duration,
            $tool,
            $detailsHash)
    }

    $metadataHash = if ($MetadataPayload) {
        ConvertTo-CanonicalJson -InputObject $MetadataPayload
    }
    else {
        ''
    }

    return '{0}|{1}|{2}|{3}' -f $Timestamp.ToString('o'), $Outcome, ($checksForSignature -join ';'), $metadataHash
}

function ConvertTo-HashtableRecursive {
    param(
        [AllowNull()]
        $Value
    )

    if ($null -eq $Value) {
        return $null
    }

    if ($Value -is [System.Collections.IDictionary]) {
        $result = @{}
        foreach ($key in $Value.Keys) {
            $result[$key] = ConvertTo-HashtableRecursive -Value $Value[$key]
        }
        return $result
    }

    if ($Value -is [System.Collections.IEnumerable] -and -not ($Value -is [string])) {
        $list = @()
        foreach ($item in $Value) {
            $list += ,(ConvertTo-HashtableRecursive -Value $item)
        }
        return $list
    }

    return $Value
}

$resolvedLedgerPath = Resolve-Path -Path $LedgerPath -ErrorAction SilentlyContinue
if (-not $resolvedLedgerPath) {
    throw "Ledger not found: $LedgerPath"
}

$schemaRoot = Join-Path -Path (Split-Path -Path $PSScriptRoot -Parent) -ChildPath '..'
$schemaPath = Join-Path -Path (Resolve-Path -Path $schemaRoot).Path -ChildPath 'schemas/ledger.schema.json'

$signingKeyBytes = Get-SigningKeyBytes -Path $SigningKeyPath -SecureKey $SigningKey

$lineNumber = 0
$results = @()
foreach ($line in [System.IO.File]::ReadLines($resolvedLedgerPath.Path)) {
    $lineNumber++
    if ([string]::IsNullOrWhiteSpace($line)) {
        continue
    }

    if (-not (Test-Json -Json $line -SchemaFile $schemaPath)) {
        throw "Ledger entry on line $lineNumber failed schema validation."
    }

    $entryObject = $line | ConvertFrom-Json -Depth 64
    $entryHashtable = ConvertTo-HashtableRecursive -Value $entryObject

    $timestamp = [datetime]::Parse($entryHashtable['timestamp'], [System.Globalization.CultureInfo]::InvariantCulture)
    $timestamp = $timestamp.ToUniversalTime()

    $signatureStatus = 'not-validated'
    if ($signingKeyBytes) {
        if ($entryHashtable.ContainsKey('signature')) {
            $signatureValue = [string]$entryHashtable['signature']
            if ($signatureValue.StartsWith('hmacsha256:', [System.StringComparison]::OrdinalIgnoreCase)) {
                $expectedSignature = $signatureValue.Substring('hmacsha256:'.Length)
                $checks = @()
                foreach ($check in $entryHashtable['checks']) {
                    $checks += ,([pscustomobject]$check)
                }
                $sortedChecks = $checks | Sort-Object -Property name
                $metadataForSignature = if ($entryHashtable.ContainsKey('metadata')) { $entryHashtable['metadata'] } else { $null }
                $payload = ConvertTo-SignatureString -Timestamp $timestamp -Outcome $entryHashtable['result'] -CheckItems $sortedChecks -MetadataPayload $metadataForSignature
                $payloadBytes = [System.Text.Encoding]::UTF8.GetBytes($payload)
                $hmac = [System.Security.Cryptography.HMACSHA256]::new($signingKeyBytes)
                try {
                    $computed = [Convert]::ToBase64String($hmac.ComputeHash($payloadBytes))
                }
                finally {
                    $hmac.Dispose()
                }

                if ($computed -eq $expectedSignature) {
                    $signatureStatus = 'valid'
                }
                else {
                    $signatureStatus = 'invalid'
                }
            }
            else {
                $signatureStatus = 'unsupported-algorithm'
            }
        }
        else {
            $signatureStatus = 'missing'
        }
    }
    elseif ($entryHashtable.ContainsKey('signature')) {
        $signatureStatus = 'present-not-validated'
    }

    $record = [ordered]@{
        LineNumber       = $lineNumber
        Timestamp        = $timestamp
        Result           = $entryObject.result
        SignatureStatus  = $signatureStatus
        Entry            = $entryObject
    }

    if ($IncludeRaw.IsPresent) {
        $record['Raw'] = $line
    }

    $results += ,([pscustomobject]$record)
}

if ($AsJson.IsPresent) {
    $results | ConvertTo-Json -Depth 64
}
else {
    $results
}
