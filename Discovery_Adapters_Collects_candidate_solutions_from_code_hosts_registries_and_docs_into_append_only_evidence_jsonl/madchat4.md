Great instinct. Solve it with a **Two-ID filename tag** + a tiny **nameguard** that enforces it on add/edit/remove.

# The idea (fast)

Give every module a short, **human mnemonic** + **stable hash shard** (Two-ID), and **prefix** every file in that module with this tag. A small guard script + pre-commit/CI keeps names correct automatically.

# 1) Two-ID tag (per module)

* **Mnemonic (MN)**: deterministic from the module key (first letters of words).

  * `plan_ingestor` → `PI`, `domain_router` → `DR`, `workstream_planner` → `WP`, `synthesizer` → `SY`, etc.
* **Hash shard (HS)**: stable, short code from the module key (e.g., base32(CRC32(key)) → 3 chars).
* **Two-ID (TID)**: `MN-HS` (e.g., `DR-5K9`, `SY-2QJ`). Store once in a **registry**.

**Registry file** (single source of truth):

```
/modules/registry.yaml
modules:
  domain_router:   { mnemonic: DR, hash: 5K9, color: "#6b8e23" }
  workstream_planner:{ mnemonic: WP, hash: A2F, color: "#1f77b4" }
  synthesizer:     { mnemonic: SY, hash: 2QJ, color: "#9467bd" }
  ...
```

# 2) Filename pattern (visual + machine-checkable)

```
{TID}.{role}[.{name}].{ext}
```

* **Roles (enum)**: `run`, `config`, `schema`, `example`, `rules`, `adapter`, `renderer`, `patcher`,
  `guard`, `verify`, `select`, `export`, `ledger`, `policy`, `cache`, `ratelimit`, `queue`,
  `autofix`, `harness`, `prov`, `rollback`, `emitci`, `emitpre`, `metrics`, `reuse`.
* **Examples (domain_router)**

  * `DR-5K9.run.py`
  * `DR-5K9.rules.yaml`
  * `DR-5K9.schema.contract.json`
  * `DR-5K9.config.yaml`
  * `DR-5K9.adapter.github.py`
* **Nested helpers** still carry the tag: `adapters/DR-5K9.adapter.pypi.py`, `templates/DR-5K9.renderer.gha.py`

**Validation regex** (one example):

```
^[A-Z]{2}-[A-Z0-9]{3}\.(run|config|schema|example|rules|adapter|renderer|patcher|guard|verify|select|export|ledger|policy|cache|ratelimit|queue|autofix|harness|prov|rollback|emitci|emitpre|metrics|reuse)(\.[a-z0-9_-]+)?\.(py|ps1|json|ya?ml|toml)$
```

# 3) Minimal automation (so it stays organized)

**A. nameguard (module linter/renamer)**

* Reads `/modules/registry.yaml`
* Computes expected TID for each module dir
* **Warns/renames** files to match the pattern; updates an **index** (stable imports)
* Outputs JSONL of changes for your ledger

**B. Stable import surface (avoids breakage when files rename)**

* Each module dir exposes `api.py` **without the TID** (stays constant):

  * `from .DR_5K9_run import main as run` (auto-generated by nameguard)
* Your orchestrator imports `modules.domain_router.api` only—**never** the TID’d filenames.

**C. Hooks**

* **pre-commit**: run `nameguard --fix --changed` (fails if unresolved)
* **CI**: run `nameguard --check --all` (no renames allowed on CI)
* **Watcher**: optional; auto-fix on file save in `/modules/**`

# 4) File skeleton per module (after naming)

```
modules/<module-key>/
  DR-5K9.run.py
  DR-5K9.config.yaml
  DR-5K9.schema.contract.json
  DR-5K9.example.input.json
  DR-5K9.rules.yaml
  api.py                 # generated by nameguard, stable import surface
  __init__.py            # empty; package marker
  adapters/
    DR-5K9.adapter.github.py
    DR-5K9.adapter.pypi.py
  templates/
    DR-5K9.renderer.python_invoke.py
  tests/                 # optional; follows same TID prefix
    DR-5K9.verify.smoke.py
```

# 5) Deterministic TID generation (no manual work)

* Compute `MN` = first letters of snake_case words (cap’d to 2 letters).
* Compute `HS` = base32(CRC32(module_key))[:3].
* If a collision ever occurs, bump to 4 chars **once** and record in registry; the guard checks this.

# 6) Safety & UX details

* **Header tag** at file top (also machine-checked):
  `# TID: DR-5K9  module: domain_router  registry: v1`
* **Short names**: keep under ~40 chars total—quickly scannable in IDEs.
* **Windows-safe**: avoid spaces/emoji; use ASCII, dots, hyphens, underscores only.

# 7) Operational flow

1. Add a file → pre-commit runs **nameguard** → it auto-prefixes with the module’s TID and rewrites `api.py`.
2. Rename/move a file → guard re-asserts pattern (and updates `api.py`).
3. Delete a file → guard cleans stale exports.
4. The GUI highlights with the module’s **registry color** and TID chip (e.g., DR-5K9), making modules visually obvious.

This gives you a **zero-guess, always-organized** module directory: filenames scream their module, the import path never changes, and automation keeps it true as files are added, removed, or edited.
