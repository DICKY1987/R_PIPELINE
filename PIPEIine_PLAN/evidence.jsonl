{"type": "Modular/Plugin Design", "repo": "pyinvoke/invoke", "location": "invoke/loader.py", "summary": "invoke discovers tasks in a tasks.py file by default, but can be configured to load tasks from a directory (e.g., tasks/). This allows for organizing tasks into logical groups, which improves maintainability and scalability.", "code_refs": "Loader.load_collection", "maturity": "High", "relevance_to_master_plan": "High", "adoption_complexity": "Low", "touches": "Master Plan Phase 4, Workstream 4A (Workstream Planner); Streamlined Watcher (tasks.py)", "Two-ID mapping": "Work_Stream_Planner_WP-A2F"}
{"type": "Modular/Plugin Design", "repo": "pyinvoke/invoke", "location": "invoke/collection.py", "summary": "invoke uses a Collection object to organize tasks into a hierarchical namespace. This allows for avoiding name collisions and creating a clear and intuitive CLI.", "code_refs": "Collection.add_collection, Collection.to_contexts", "maturity": "High", "relevance_to_master_plan": "High", "adoption_complexity": "Low", "touches": "Master Plan Phase 2, Workstream 2A (Nameguard); Streamlined Watcher (tasks.py)", "Two-ID mapping": "Goal_Normalizer_GN-7M3"}
{"type": "Pipeline Orchestration", "repo": "pyinvoke/invoke", "location": "invoke/context.py", "summary": "Every invoke task receives a Context object as its first argument. This object provides access to configuration, allows for running shell commands (ctx.run()), and can be used to pass data between tasks.", "code_refs": "Context, Context.run", "maturity": "High", "relevance_to_master_plan": "High", "adoption_complexity": "Medium", "touches": "Master Plan Phase 7, Workstream 7B (Orchestrator)", "Two-ID mapping": "Ledger_LD-3X7, Observability_OB-6W1"}
{"type": "Pipeline Orchestration", "repo": "pyinvoke/invoke", "location": "invoke/tasks.py", "summary": "invoke's @task decorator allows for specifying pre and post hooks, which are other tasks that should be executed before or after the decorated task. This is a simple yet effective way to define dependencies and orchestrate complex workflows.", "code_refs": "@task(pre=[], post=[])", "maturity": "High", "relevance_to_master_plan": "High", "adoption_complexity": "Low", "touches": "Master Plan Phase 4, Workstream 4A (Workstream Planner); Master Plan Phase 5, Workstream 5B (Verifier)", "Two-ID mapping": "Work_Stream_Planner_WP-A2F, Verifier_VR-8X4"}
{"type": "Configuration Management", "repo": "pyinvoke/invoke", "location": "invoke/config.py", "summary": "invoke provides a flexible configuration system that can load settings from invoke.yaml files, environment variables, and command-line flags. The configuration is exposed to tasks through the Context object.", "code_refs": "Config, Context.config", "maturity": "High", "relevance_to_master_plan": "High", "adoption_complexity": "Medium", "touches": "Master Plan Phase 3, Workstream 3B (Policy Pack)", "Two-ID mapping": "Policy_Pack_PP-9K2"}
{"type": "Pipeline Orchestration", "repo": "tox", "location": "tox.ini", "summary": "tox excels at creating and managing a matrix of test environments. The envlist key defines the different environments (e.g., py38, py39, lint, docs), and tox creates an isolated virtual environment for each one.", "code_refs": "envlist = py38, py39, lint", "maturity": "High", "relevance_to_master_plan": "High", "adoption_complexity": "Medium", "touches": "Master Plan Phase 5, Workstream 5B (Spike Harness)", "Two-ID mapping": "Spike_Harness_Time_boxed_sandbox_trials_to_quickly_validate_borderline_candidates_or_tie_breakers_MOD"}
{"type": "Configuration Management", "repo": "tox", "location": "tox.ini", "summary": "tox allows for conditional configuration based on 'factors'. For example, you can specify different dependencies for different Python versions or operating systems.", "code_refs": "deps = 
    -r{toxinidir}/requirements.txt
    py38: -r{toxinidir}/requirements-py38.txt", "maturity": "High", "relevance_to_master_plan": "High", "adoption_complexity": "Medium", "touches": "Master Plan Phase 3, Workstream 3B (Policy Pack)", "Two-ID mapping": "Policy_Pack_Centralizes_license_allowlists_maintenance_windows_OS_matrix_and_scoring_profiles_MOD"}
{"type": "Quality Gates", "repo": "tox", "location": ".github/workflows/main.yml", "summary": "tox is designed to be integrated into CI/CD pipelines. A common pattern is to have the CI/CD pipeline simply call tox, which then runs all the defined tests and checks.", "code_refs": "run: tox", "maturity": "High", "relevance_to_master_plan": "High", "adoption_complexity": "Low", "touches": "Master Plan Phase 6, Workstream 6B (CI/Pre-commit Integrator)", "Two-ID mapping": "CI_Pre_Commit_Integrator_Wires_gating_rules_into_hooks_and_pipelines_to_block_merges_without_fresh_verified_outputs_MOD"}
{"type": "Pipeline Orchestration", "repo": "pydoit", "location": "dodo.py", "summary": "pydoit automatically builds a Directed Acyclic Graph (DAG) of tasks based on their declared dependencies (file_dep, task_dep) and targets. This allows for efficient and parallel execution of tasks.", "code_refs": "def task_my_task():
    return {
        'file_dep': ['input.txt'],
        'targets': ['output.txt'],
        'actions': ['my_command'],
    }", "maturity": "High", "relevance_to_master_plan": "High", "adoption_complexity": "Medium", "touches": "Master Plan Phase 4, Workstream 4A (Workstream Planner)", "Two-ID mapping": "Work_Stream_Planner_Builds_a_dependency_graph_partitions_independent_work_streams_and_applies_file_locks_for_safe_parallelism_MOD"}
{"type": "Pipeline Orchestration", "repo": "pydoit", "location": "pydoit's internal state tracking", "summary": "pydoit keeps track of the state of tasks and their dependencies. If a task's inputs have not changed and its outputs are up-to-date, pydoit will skip the execution of the task.", "code_refs": "Not directly visible in user code, but it's a core feature of the tool.", "maturity": "High", "relevance_to_master_plan": "High", "adoption_complexity": "Medium", "touches": "Master Plan Phase 3, Workstream 3C (Cache/Rate-Limit)", "Two-ID mapping": "Caching_Rate_Limiter_Mirrors_raw_API_payloads_dedupes_queries_and_respects_rate_limits_backoff_MOD"}
{"type": "Watcher/Observer", "repo": "watchdog", "location": "watchdog/observers/api.py", "summary": "watchdog uses the observer pattern to monitor file system events. An Observer thread runs in the background and dispatches events to registered EventHandlers.", "code_refs": "BaseObserver, FileSystemEventHandler", "maturity": "High", "relevance_to_master_plan": "High", "adoption_complexity": "Low", "touches": "Streamlined Watcher (watch.ps1, watch.py)", "Two-ID mapping": "Not directly applicable to a specific module, but it's a foundational technology for the watcher."} 
{"type": "Watcher/Observer", "repo": "watchdog", "location": "watchdog/observers/__init__.py", "summary": "watchdog provides a platform-independent API for file system monitoring, with specific implementations for different operating systems.", "code_refs": "Observer class (which selects the appropriate implementation based on the OS)", "maturity": "High", "relevance_to_master_plan": "High", "adoption_complexity": "Low", "touches": "Streamlined Watcher (watch.ps1, watch.py)", "Two-ID mapping": "Not directly applicable."} 
{"type": "Watcher/Observer", "repo": "pytest-watch", "location": "pytest_watch/__main__.py", "summary": "pytest-watch (and its successor pytest-watcher) continuously monitors files for changes and re-runs pytest automatically. This provides immediate feedback to developers and facilitates a test-driven development workflow.", "code_refs": "The main loop in pytest_watch/__main__.py", "maturity": "High", "relevance_to_master_plan": "High", "adoption_complexity": "Low", "touches": "Streamlined Watcher (build.ps1, tasks.py)", "Two-ID mapping": "Verifier_Runs_static_checks_smoke_tests_and_time_boxed_runtime_probes_in_disposable_envs_containers_MOD"}
{"type": "Quality Gates", "repo": "Ruff", "location": "Not applicable (core design principle)", "summary": "Ruff is designed to replace a multitude of existing Python tools, including linters like Flake8, code formatters like Black, and import sorters like isort.", "code_refs": "Not applicable", "maturity": "High", "relevance_to_master_plan": "High", "adoption_complexity": "Low", "touches": "Master Plan Phase 5, Workstream 5B (Verifier)", "Two-ID mapping": "Verifier_Runs_static_checks_smoke_tests_and_time_boxed_runtime_probes_in_disposable_envs_containers_MOD"}
{"type": "Quality Gates", "repo": "Ruff", "location": "Not applicable (internal implementation detail)", "summary": "Ruff has a built-in caching system that prevents the re-analysis of unchanged files. This results in extremely fast performance, especially in large codebases.", "code_refs": "Not applicable", "maturity": "High", "relevance_to_master_plan": "High", "adoption_complexity": "Low", "touches": "Master Plan Phase 3, Workstream 3C (Cache/Rate-Limit)", "Two-ID mapping": "Caching_Rate_Limiter_Mirrors_raw_API_payloads_dedupes_queries_and_respects_rate_limits_backoff_MOD"}
{"type": "Quality Gates", "repo": "PSScriptAnalyzer", "location": "Not applicable (core design principle)", "summary": "PSScriptAnalyzer uses a rule-based engine to evaluate PowerShell code against a set of best practices. The rules are configurable and can be extended with custom rules.", "code_refs": "Invoke-ScriptAnalyzer cmdlet", "maturity": "High", "relevance_to_master_plan": "High", "adoption_complexity": "Low", "touches": "Master Plan Phase 5, Workstream 5B (Verifier)", "Two-ID mapping": "Verifier_Runs_static_checks_smoke_tests_and_time_boxed_runtime_probes_in_disposable_envs_containers_MOD"}
{"type": "Quality Gates", "repo": "PSScriptAnalyzer", "location": "Not applicable (integration with other tools)", "summary": "PSScriptAnalyzer is tightly integrated with the PowerShell extension for VS Code, providing real-time feedback to developers as they write code.", "code_refs": "Not applicable", "maturity": "High", "relevance_to_master_plan": "High", "adoption_complexity": "Low", "touches": "Streamlined Watcher", "Two-ID mapping": "Not directly applicable."} 
{"type": "Distribution & Reuse", "repo": "GitHub Actions", "location": ".github/workflows/reusable-workflow.yml", "summary": "GitHub Actions allows you to create reusable workflows that can be called from other workflows. This is a powerful pattern for creating a centralized and reusable library of CI/CD pipelines.", "code_refs": "on: { workflow_call: ... }", "maturity": "High", "relevance_to_master_plan": "High", "adoption_complexity": "Medium", "touches": "Master Plan Phase 6, Workstream 6B (Playbook Promoter)", "Two-ID mapping": "Playbook_Promoter_Elevates_verified_solutions_into_reusable_internal_proven_playbooks_for_future_runs_MOD"}
{"type": "Distribution & Reuse", "repo": "GitHub Actions", "location": "action.yml", "summary": "Composite actions allow you to combine multiple workflow steps into a single action. This is a great way to reduce duplication and simplify complex workflows.", "code_refs": "runs: { using: 'composite', steps: [...] }", "maturity": "High", "relevance_to_master_plan": "High", "adoption_complexity": "Low", "touches": "Master Plan Phase 5, Workstream 5B (Verifier)", "Two-ID mapping": "Verifier_Runs_static_checks_smoke_tests_and_time_boxed_runtime_probes_in_disposable_envs_containers_MOD"}
{"type": "Distribution & Reuse", "repo": "Cookiecutter", "location": "cookiecutter.json", "summary": "Cookiecutter uses a cookiecutter.json file to define a set of variables that are used to generate a project from a template. The template itself is a directory structure that contains files with Jinja2 template syntax.", "code_refs": "cookiecutter.json", "maturity": "High", "relevance_to_master_plan": "High", "adoption_complexity": "Medium", "touches": "Master Plan Phase 5, Workstream 5A (Synthesizer)", "Two-ID mapping": "Synthesizer_Generates_new_files_or_edits_via_capability_template_mappings_to_satisfy_deliverables_MOD"}
{"type": "Distribution & Reuse", "repo": "Cookiecutter", "location": "hooks/", "summary": "Cookiecutter supports pre- and post-generation hooks, which are scripts that can be run before or after a project is generated. This allows for advanced customization and automation.", "code_refs": "hooks/pre_gen_project.py, hooks/post_gen_project.py", "maturity": "High", "relevance_to_master_plan": "High", "adoption_complexity": "Medium", "touches": "Master Plan Phase 5, Workstream 5A (Synthesizer)", "Two-ID mapping": "Synthesizer_Generates_new_files_or_edits_via_capability_template_mappings_to_satisfy_deliverables_MOD"}
{"type": "VCS Hygiene & Automation", "repo": "Conventional Commits", "location": "Not applicable (a specification)", "summary": "Conventional Commits provide a structured format for commit messages, including a type, an optional scope, a description, an optional body, and an optional footer. This structure allows for automated changelog generation and automated versioning.", "code_refs": "<type>[optional scope]: <description>", "maturity": "High", "relevance_to_master_plan": "High", "adoption_complexity": "Low", "touches": "Master Plan Phase 6, Workstream 6B (Playbook Promoter)", "Two-ID mapping": "Playbook_Promoter_Elevates_verified_solutions_into_reusable_internal_proven_playbooks_for_future_runs_MOD"}
{"type": "VCS Hygiene & Automation", "repo": "Semantic Versioning (SemVer)", "location": "Not applicable (a specification)", "summary": "SemVer uses a three-part version number: MAJOR.MINOR.PATCH. The MAJOR version is incremented for incompatible API changes, the MINOR version is incremented for backward-compatible API additions, and the PATCH version is incremented for backward-compatible bug fixes.", "code_refs": "MAJOR.MINOR.PATCH", "maturity": "High", "relevance_to_master_plan": "High", "adoption_complexity": "Low", "touches": "The entire project.", "Two-ID mapping": "Not directly applicable."} 
{"type": "Registries & APIs", "repo": "PyPI JSON API", "location": "https://pypi.org/pypi/<project_name>/json", "summary": "The PyPI JSON API provides a machine-readable interface to access metadata about Python packages, including version information, release details, and vulnerability data.", "code_refs": "Not applicable", "maturity": "High", "relevance_to_master_plan": "High", "adoption_complexity": "Low", "touches": "Master Plan Phase 4, Workstream 4B (Discovery Adapters)", "Two-ID mapping": "Discovery_Adapters_Collects_candidate_solutions_from_code_hosts_registries_and_docs_into_append_only_evidence_jsonl_MOD"}
{"type": "Registries & APIs", "repo": "GitHub REST & Code Search", "location": "https://api.github.com/search/code", "summary": "The GitHub REST API provides a powerful endpoint for searching code across all of GitHub. The search can be narrowed down by language, repository, user, and other criteria.", "code_refs": "Not applicable", "maturity": "High", "relevance_to_master_plan": "High", "adoption_complexity": "Medium", "touches": "Master Plan Phase 4, Workstream 4B (Discovery Adapters)", "Two-ID mapping": "Discovery_Adapters_Collects_candidate_solutions_from_code_hosts_registries_and_docs_into_append_only_evidence_jsonl_MOD"}
{"type": "Portable workflow specs", "repo": "CWL (Common Workflow Language)", "location": "Not applicable (a specification)", "summary": "CWL provides a declarative way to define workflows in YAML or JSON. A CWL document can define a CommandLineTool (how to run a single command-line program) or a Workflow (connecting multiple tools or sub-workflows).", "code_refs": "Not applicable", "maturity": "Medium", "relevance_to_master_plan": "Medium", "adoption_complexity": "High", "touches": "Master Plan Phase 7, Workstream 7B (Orchestrator)", "Two-ID mapping": "Work_Stream_Planner_Builds_a_dependency_graph_partitions_independent_work_streams_and_applies_file_locks_for_safe_parallelism_MOD"}
{"type": "Cross-language task runners", "repo": "Taskfile.dev (Task)", "location": "Taskfile.yml", "summary": "Task uses a YAML file (Taskfile.yml) to define tasks and their dependencies. This is a simple and intuitive way to define tasks, and it is language-agnostic.", "code_refs": "tasks: { my-task: { cmds: ['echo "Hello World"'] } }", "maturity": "High", "relevance_to_master_plan": "High", "adoption_complexity": "Medium", "touches": "Master Plan Phase 7, Workstream 7B (Orchestrator)", "Two-ID mapping": "Work_Stream_Planner_Builds_a_dependency_graph_partitions_independent_work_streams_and_applies_file_locks_for_safe_parallelism_MOD"}
{"type": "Cross-language task runners", "repo": "Taskfile.dev (Task)", "location": "Not applicable (internal implementation detail)", "summary": "Task has a smart caching mechanism that can skip unnecessary task executions by tracking file changes. This is a powerful feature for optimizing build times and avoiding redundant work.", "code_refs": "Not applicable", "maturity": "High", "relevance_to_master_plan": "High", "adoption_complexity": "Medium", "touches": "Master Plan Phase 3, Workstream 3C (Cache/Rate-Limit)", "Two-ID mapping": "Caching_Rate_Limiter_Mirrors_raw_API_payloads_dedupes_queries_and_respects_rate_limits_backoff_MOD"}